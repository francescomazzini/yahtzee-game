{
  "version": 3,
  "sources": ["../index.ts"],
  "sourcesContent": ["// this is a library we need, to read text input \"easily\"\nimport prompt from 'prompt-sync';\n\nconst input = prompt();\n\n//declared generic type of functions because for some reason they are not already present\ntype transform<A, B> = (arg: A) => B;\ntype predicate<A> = (arg: A) => boolean;\ntype reducer<A, B> = (acc: B, val: A) => B;\n\n// these are some codes to get the console to print in colors\n// see more details here:\n// https://bit.ly/3T8YcDQ\nconst Reset = \"\\x1b[0m\";\nconst BgRed = \"\\x1b[41m\";\nconst BgGreen = \"\\x1b[42m\";\nconst BgYellow = \"\\x1b[43m\";\nconst BgBlue = \"\\x1b[44m\";\nconst BgMagenta = \"\\x1b[45m\";\nconst BgCyan = \"\\x1b[46m\";\nconst BgWhite = \"\\x1b[47m\";\n\n\n//define the player interface\ninterface Player {\n  //color can be green, yellow, blue or magenta\n  color: string,\n  // color: string,\n  score: number[]\n}\n\nconst N_DIES: number = 5;\n\ntype Die = 1 | 2 | 3 | 4 | 5 | 6;\n\n\n//this function creates the number of player wanted and set up their colors and score (default value)\nconst createPlayer = (numberNewPlayer: number): Player[] => {\n\n  if (numberNewPlayer < 1)\n    return [];\n\n  return [...createPlayer(numberNewPlayer - 1), {\n    color:\n      `\\x1b[4${numberNewPlayer + 1}m`, score: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  }];\n\n}\n\n\n//this function will manage the setup part (beginning) of the game\nconst startGame = (): Player[] => {\n\n  console.log('Welcome to Yahtzee Game!');\n\n  //magari dovrei separare e emettere questo in un'altra funzione per ridurre l'uso dell'interazione\n\n  const numberOfPlayers: number = getNumberOfPlayer();\n\n  return createPlayer(numberOfPlayers);\n\n}\n\n//this function will manage the correctness of the input of the \n//number of players (a value between 1-4) and return the correct value\n//when received\nconst getNumberOfPlayer = (): number => {\n  const answer = input(`How many people are going to play? (1-4) `)\n  switch (answer) {\n    case \"1\": return 1\n    case \"2\": return 2\n    case \"3\": return 3\n    case \"4\": return 4\n    default: {\n      console.log(\"Invalid number, please choose a number of players(1-4) \")\n      return getNumberOfPlayer();\n    }\n  }\n}\n\n//this functions roll a number of dice\nconst rollDice = (numberDice: number): Die[] => {\n  if (numberDice < 1)\n    return [];\n  else\n    return [(Math.trunc(Math.random() * 6) + 1) as Die, ...rollDice(numberDice - 1)];\n}\n\n//this function recursively use the indexes to generate the new array\n//of dice that the user wanted to keep\nconst whichDieToKeep = ([index1, ...indexes]: number[], dice: Die[]): Die[] => {\n  if (index1 !== undefined)\n    return [dice[index1], ...whichDieToKeep(indexes, dice)];\n\n  return [];\n}\n\n//this function asks the user one die to keep and manages the check on the input\nconst indexOfDie = (): number => {\n\n  console.log(`Which of the dice, would you like to keep? Write the number of their position (1-5) or write 0 to stop choosing (if you don't want any, write immediately 0)`)\n\n  const answer = input();\n\n  //VALUTA IL RAGGRUPPARE QUESTI SWITCH IN UNA FUNZIONE, MAGARI HIGH ORDER FUNCTIONS???\n\n  switch (answer) {\n    case '0':\n      return 0;\n    case '1':\n      return 1;\n    case '2':\n      return 2;\n    case '3':\n      return 3;\n    case '4':\n      return 4;\n    case '5':\n      return 5;\n    default: {\n      console.log(\"Invalid number, please choose a number between 1-5 or 0 \");\n    }\n\n  }\n\n  return indexOfDie();\n\n}\n\n//this function gathers all the indexes for the dice that the user wants to keep\nconst indexOfDice = (counter: number, indexes: number[]): number[] => {\n\n  if (counter > N_DIES)\n    return [];\n\n  const index: number = indexOfDie();\n\n  if (index !== 0) {\n\n    if (indexes.some((i: number) => i === index)) {\n      console.log(\"You can't choose the same die twice\");\n      return [...indexOfDice(counter, indexes)];\n    } else\n      return [index, ...indexOfDice(counter + 1, [index, ...indexes])];\n  }\n\n  return [];\n\n}\n\n//this function manages the functions for deciding which die to keep. \n//It also maps their indexes because the user inserts them from 1 to 5 \n//and instead they are needed from 0 to 4\nconst askDiceToKeep = (dice: Die[]): Die[] => {\n\n  const indexDiceKeep: number[] = indexOfDice(1, []);\n  const newDice: Die[] = indexDiceKeep.length === N_DIES ? dice\n    : whichDieToKeep(indexDiceKeep.map((i: number) => i - 1), dice);\n\n  console.log(\"You kept the following dice: \");\n  console.log(newDice);\n\n  return newDice;\n\n}\n\n//this function takes care to transform the combination chosen as a string to a number that refers to the cell of the array of the score owned by the player\nconst transformCombination = (): number => {\n\n  console.log(`Which of the combination, you'd like to assign your dice points?`)\n\n  const answer = input();\n\n  switch (answer) {\n    case 'Ones':\n      return 0;\n    case 'Twos':\n      return 1;\n    case 'Threes':\n      return 2;\n    case 'Fours':\n      return 3;\n    case 'Fives':\n      return 4;\n    case 'Sixes':\n      return 5;\n    case 'Three of a kind':\n      return 6;\n    case 'Four of a kind':\n      return 7;\n    case 'Full House':\n      return 8;\n    case 'Small Straight':\n      return 9;\n    case 'Large Straight':\n      return 10;\n    case 'Chance':\n      return 11;\n    case 'YAHTZEE':\n      return 12;\n    default: {\n      console.log(\"Invalid choice, you must use the names of the combinations, displayed in the point table\");\n    }\n\n  }\n\n  return transformCombination();\n\n}\n\n//this function takes care of all of the process of asking in which combination wants now the player put its gaines points and its main task is to check that the user is not trying to put the points on a combination already filled\nconst askCombination = ({ score, ...player }: Player): number => {\n\n  const combinationChosen: number = transformCombination();\n\n  if (score[combinationChosen] !== 0) {\n    console.log(\"You can't assign the score to this combination because you already did in the past! Please choose another one\");\n    return askCombination({ score, ...player });\n  }\n\n  return combinationChosen;\n\n}\n\n//all the functions that are going to take care to evaluate the number of points will be of the following type\ntype fromDiceToScore = (arg: Die[]) => number;\n\n//this function will take care to convert the combination of the Dies chosen in its score\nconst getScoreComputation = (combination: number): fromDiceToScore => {\n\n  const sumDice = (dice: Die[]): number => dice.reduce((sum: number, d: Die) => sum + d, 0);\n\n  switch (combination) {\n    case 0:\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n      //return a functions that compute the sum of all the dice, after having filtered only those which are of a specific number given by the combination type\n      return (dice: Die[]): number => sumDice(dice.filter((d: Die) => d === (combination + 1)));\n    case 6:\n    case 7:\n    case 8:\n    case 12:\n      {\n        //this function maps all the dice to an array in which for each position there is the number of times that number appears in the array\n        const frequencyMap: transform<Die[], number[]> = (dice: Die[]): number[] => dice.map((die: Die): number => dice.reduce((sum: number, d1: Die) => sum + (die === d1 ? 1 : 0), 0));\n\n        //this function checks if in the frequency map result there is such a number(given specifically later, also the criteria (=== or >=) is given later), meaning that a certain die is present a certain number of times in the dice array\n        const isThere = (frequencyMap: transform<Die[], number[]>, condition: predicate<number>, dice: Die[]): boolean => frequencyMap(dice).some((n: number) => condition(n))\n\n        switch (combination) {\n          case 6:\n          case 7:\n            //so for Three of a kind the number of sam eDie has to be >= (6-3 =) 3 and for the Four od a kind, it has to be >= (7-3 = ) 4 instead\n            return (dice: Die[]): number =>\n              isThere(frequencyMap, (n: number) => n >= (combination - 3), dice) ? sumDice(dice) : 0;\n          //for the full house there has to be 3 of a kind and 2 of another one\n          case 8:\n            return (dice: Die[]): number =>\n              isThere(frequencyMap, (n: number) => n === 3, dice) &&\n                isThere(frequencyMap, (n: number) => n === 2, dice) ? 25 : 0;\n          //for the YAHTZEE there has to be 5 dice of the same number\n          case 12:\n            return (dice: Die[]): number =>\n              isThere(frequencyMap, (n: number) => n === 5, dice) ? 50 : 0;\n        }\n      }\n\n    case 9:\n    case 10: {\n\n      //this function sorts the dice returning a new array (thats why [...dice] because sort() sorts in place)\n      const sortedDice = (dice: Die[]) => [...dice].sort((a: number, b: number) => a - b);\n      //this functions checks if there are a straight line of a certain number of dice (this is given later with specific conditions, it's not very clear and abstract but these two refer to really specific cases and making them more reusable and abstract in a cleaner way would have neem to time expensive, this is anyway a way to avoid code duplication) \n      const isStraight = (dice: Die[], conditionIndex: predicate<number>, conditionEdgeCase: predicate<Die[]>): boolean => {\n        return dice.reduce((isIt: boolean, d: Die, i: number, ds: Die[]): boolean => {\n          if (i < ds.length - 2 && conditionIndex(i))\n            isIt = isIt && d === (ds[i + 1] - 1);\n          else\n            isIt = isIt && (conditionEdgeCase(ds) || ds[ds.length - 1] === (ds[ds.length - 2] + 1));\n          //this check on the length is made only for the case of the small straight where removing the duplicates could cause a fake approval of the condition \n          return isIt && ds.length >= 4;\n        }, true);\n      }\n\n      switch (combination) {\n        case 9:\n          //for small straight we avoid to have the duplicates annoying the calculation using the set object instead. The condition allows to avoid to check the first and last result in a strict way, because on of the two can also not respect the criteria (since the straihgtness should be only given by at least 4 numbers)\n          return (dice: Die[]): number => isStraight([...new Set(sortedDice(dice))], (i: number) => i > 0, (ds: Die[]) => ds[0] === (ds[1] - 1)) ? 30 : 0;\n        case 10:\n          //here instead is more strict, therefore there cannot be duplicates, no first and last allowed to not respect the criteria\n          return (dice: Die[]): number => isStraight(sortedDice(dice), (i: number) => true, (ds: Die[]) => false) ? 40 : 0;\n      }\n\n    }\n\n    //chanche just sums the number of the dice\n    case 11:\n      return (dice: Die[]): number => sumDice(dice);\n\n  }\n\n  return (dice: Die[]): number => 0;\n\n}\n\n//this function manages the update of the player score\nconst newPlayerScore = (converter: fromDiceToScore, combination: number, { score, ...player }: Player, dice: Die[]): Player => {\n\n  const beforeScore: number[] = score.slice(0, combination);\n  const afterScore: number[] = score.slice(combination + 1, score.length);\n\n  return { score: [...beforeScore, converter(dice), ...afterScore], ...player };\n}\n\n//this function manages the turn of a player in which he rolls dice\nconst turn = (currentPlayer: Player, numberRound: 1 | 2 | 3, dice: Die[]): Player => {\n\n  const tempDice: Die[] = [...dice, ...rollDice(N_DIES - dice.length)];\n\n  if (dice.length != 5) {\n    console.log(\"The dice have been rolled\");\n    console.log(\"Their values are: \");\n    console.log(tempDice);\n  }\n\n  if (numberRound !== 3) {\n\n    const keptDice: Die[] = askDiceToKeep(tempDice);\n\n    if (keptDice.length === N_DIES)\n      return turn(currentPlayer, 3, keptDice);\n\n    return turn(currentPlayer, numberRound + 1 as 1 | 2 | 3, keptDice);\n\n  } else {\n\n    const combination: number = askCombination(currentPlayer);\n\n    return newPlayerScore(getScoreComputation(combination), combination, currentPlayer, tempDice);\n\n  }\n\n  return { ...currentPlayer };\n\n}\n\nconst getWinner = (players: Player[]): Player[] => {\n  // return players.map((player: Player[], i: number) => ({ player: player, num: i })).sort()//posso fare il sort sul number e poi filter dei player con il punteggio piu alto, ma devo ptims prt ciascuno calcolare il totale dei loro punti \n\n  interface playerWScore {\n    player: Player,\n    total: number\n  }\n\n  const sortedByPoints: playerWScore[] = players\n    .map((player: Player): playerWScore =>\n    ({\n      player: player,\n      total: player.score\n        .reduce((sum: number, n: number): number => sum = sum + n, 0)\n    })\n    )\n    .sort((p1: playerWScore, p2: playerWScore) => p2.total - p1.total);\n\n  return sortedByPoints\n    .filter(({ player, total }: playerWScore) => total === sortedByPoints[0].total)\n    .map(({ player, total }: playerWScore): Player => player);\n}\n\n//this function manages all the middle part of the game in which players actually play\nconst midGame = (players: Player[], playerNumber: number, numberRound: number): Player[] => {\n\n  if (playerNumber === 0 && numberRound === 14)\n    return getWinner(players);\n\n  if (playerNumber === 0)\n    console.log(\"Turn Number #\" + numberRound);\n\n  console.log(players);\n  console.log(\"It's your turn, color \" + getColor(players[playerNumber].color));\n\n  const newPlayerState: Player = turn(players[playerNumber], 1, []);\n\n  const newPlayers: Player[] = players;\n  newPlayers[playerNumber] = newPlayerState;\n\n  const next: number = (playerNumber + 1) % players.length;\n\n  return midGame(newPlayers, next, next === 0 ? numberRound + 1 : numberRound);\n}\n\nconst getColor = (color: string): string => {\n  switch (color) {\n    case '\\x1b[42m':\n      return 'GREEN';\n    case '\\x1b[43m':\n      return 'YELLOW';\n    case '\\x1b[44m':\n      return 'BLUE';\n    case '\\x1b[45m':\n      return 'MAGENTA';\n  }\n\n  return '????'\n}\n\nconst announceWinner = (players: Player[]): void => {\n\n  console.log(\"The game is finished.\")\n\n  if (players.length === 1)\n    console.log(`...and the winner is...\n    ...COLOR ${getColor(players[0].color)}. Congratulations!`);\n  else\n    console.log(`...ugh... it seems there's a draw!\nSo the winners are...\n    ... COLOR ${players.reduce((sum: string, p: Player): string => sum = sum + (sum !== '' ? \", \" : '') + getColor(p.color), '')}. Congratulations!`);\n}\n\n//this function will manage the structure of the game itself\n//referring to any possible and needed state of the game\nconst game = (): void => {\n  const players: Player[] = startGame();\n\n  //return the winner(s) or null if there's a total draw\n  const winner: Player[] = midGame(players, 0, 13);\n\n  announceWinner(winner);\n\n}\n\ngame();\n"],
  "mappings": "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",
  "names": []
}

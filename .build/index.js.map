{
  "version": 3,
  "sources": ["../index.ts"],
  "sourcesContent": ["// this is a library we need, to read text input \"easily\"\nimport prompt from 'prompt-sync';\n\n\n//------------------------\n\n//INITIAL DECLARATIONS\n\n//------------------------\n\nconst input = prompt();\n\n//declared generic type of functions because for some reason they are not already present\nexport type transform<A, B> = (arg: A) => B;\nexport type predicate<A> = (arg: A) => boolean;\nexport type reducer<A, B> = (acc: B, val: A) => B;\n\nexport type Die = 1 | 2 | 3 | 4 | 5 | 6;\n\n//all the functions that are going to take care to evaluate the number of points will be of the following type\nexport type fromDiceToScore = (arg: Die[]) => number;\n\n// these are some codes to get the console to print in colors\n// see more details here:\n// https://bit.ly/3T8YcDQ\nconst Reset = \"\\x1b[0m\";\nconst BgRed = \"\\x1b[41m\";\nconst BgGreen = \"\\x1b[42m\";\nconst BgYellow = \"\\x1b[43m\";\nconst BgBlue = \"\\x1b[44m\";\nconst BgMagenta = \"\\x1b[45m\";\nconst BgCyan = \"\\x1b[46m\";\nconst BgWhite = \"\\x1b[47m\";\n\n//represents the structure of the score (name, position in the array, value of points assigned, already chosen or not by the player)\ninterface Score {\n  name: string,\n  position: number,\n  value: number,\n  used: boolean //says if the combination has already been chosen\n}\n\n//define the player interface\ninterface Player {\n  //color can be green, yellow, blue or magenta\n  color: string,\n  score: Score[]\n}\n\nconst N_DIES: number = 5;\n\n\nconst getNameScore = (): string[] => [\"Ones\", \"Twos\", \"Threes\", \"Fours\", \"Fives\",\n  \"Sixes\", \"Three of a kind\", \"Four of a kind\", \"Full house\", \"Small straight\",\n  \"Large straight\", \"Chance\", \"YAHTZEE\"];\n\n//------------------------\n\n//DICE UTILITIES\n\n//------------------------\n\n//function that sums all the dice\nconst sumDice = (dice: Die[]): number => dice.reduce((sum: number, d: Die) => sum + d, 0);\n\n//this function maps all the dice to an array in which for each position there is the number of times that number appears in the array\nconst frequencyMap: transform<Die[], number[]> = (dice: Die[]): number[] => dice.map((die: Die): number => dice.reduce((sum: number, d1: Die) => sum + (die === d1 ? 1 : 0), 0));\n\n//this function checks if in the frequency map result if there is such a number(given specifically later, also the criteria (=== or >=) is given later), meaning that a certain die is present a certain number of times in the dice array\nconst isThere = (frequencyMap: transform<Die[], number[]>, condition: predicate<number>, dice: Die[]): boolean => frequencyMap(dice).some((n: number) => condition(n))\n\n//this function sorts the dice returning a new array (thats why [...dice] because sort() sorts in place)\nconst sortedDice = (dice: Die[]) => [...dice].sort((a: number, b: number) => a - b);\n\n//this function checks if there are a straight line of a certain number of dice (this is given later with specific conditions, it's not very clear and abstract but these two refer to really specific cases and making them more reusable and abstract in a cleaner way would have needed other time, this is anyway a way to avoid code duplication) \nconst isStraight = (dice: Die[], conditionIndex: predicate<number>, conditionEdgeCase: predicate<Die[]>): boolean => {\n  return dice.reduce((isIt: boolean, d: Die, i: number, ds: Die[]): boolean => {\n    if (i < ds.length - 2 && conditionIndex(i))\n      isIt = isIt && d === (ds[i + 1] - 1);\n    else\n      isIt = isIt && (conditionEdgeCase(ds) || ds[ds.length - 1] === (ds[ds.length - 2] + 1));\n    //this check on the length is made only for the case of the small straight where removing the duplicates could cause a fake approval of the condition \n    return isIt && ds.length >= 4;\n  }, true);\n}\n\n//return a function that computes the sum of all the dice, after having filtered only those which are of a specific number given by the combination type\nconst diceSumIfNum = (num: number): fromDiceToScore => (dice: Die[]): number => sumDice(dice.filter((d: Die) => d === num));\n\nconst numOfAKind = (num: number): fromDiceToScore => (dice: Die[]): number =>\n  isThere(frequencyMap, (n: number) => n >= (num), dice) ? sumDice(dice) : 0;\n\nconst fullHouse = (numPoints: number): fromDiceToScore => (dice: Die[]): number =>\n  isThere(frequencyMap, (n: number) => n === 3, dice) &&\n    isThere(frequencyMap, (n: number) => n === 2, dice) ? numPoints : 0;\n\nconst YAHTZEE = (numPoints: number): fromDiceToScore => (dice: Die[]): number =>\n  isThere(frequencyMap, (n: number) => n === 5, dice) ? numPoints : 0;\n\n//for small straight we avoid to have the duplicates annoying the calculation using the set object instead. The condition allows to avoid to check the first and last result in a strict way, because one of the two can also not respect the criteria (since the straihgtness should be only given by at least 4 numbers)\nconst isSmallStraight = (numPoints: number): fromDiceToScore => (dice: Die[]): number => isStraight([...new Set(sortedDice(dice))], (i: number) => i > 0, (ds: Die[]) => ds[0] === (ds[1] - 1)) ? numPoints : 0;\n\n//here instead is more strict, therefore there cannot be duplicates, no first and last allowed to not respect the criteria\nconst isLargeStraight = (numPoints: number): fromDiceToScore => (dice: Die[]): number => isStraight(sortedDice(dice), (i: number) => true, (ds: Die[]) => false) ? numPoints : 0;\n\n//chanche just sums the number of the dice\nconst Chance = (): fromDiceToScore => (dice: Die[]): number => sumDice(dice);\n\n//this functions roll a number of dice\nconst rollDice = (numberDice: number): Die[] => {\n  if (numberDice < 1)\n    return [];\n  else\n    return [(Math.trunc(Math.random() * 6) + 1) as Die, ...rollDice(numberDice - 1)];\n}\n\n//------------------------\n\n//GAME SETUP\n\n//------------------------\n\n//it creates the number of player wanted and set up their colors and score (default value)\nconst createPlayer = (numberNewPlayer: number): Player[] => {\n\n  if (numberNewPlayer < 1)\n    return [];\n\n  return [...createPlayer(numberNewPlayer - 1), {\n    color:\n      `\\x1b[4${numberNewPlayer + 1}m`, score: setUpScore()\n  }];\n\n}\n\n//this function handles the first setup of the score\nconst setUpScore = (): Score[] => {\n  const names: string[] = getNameScore();\n  const score: Score[] = [];\n\n  for (let i = 0; i < names.length; i++) {\n    score.push({\n      name: names[i],\n      value: 0,\n      used: false,\n      position: i\n    }\n    );\n  }\n\n  return score;\n}\n\n//this function will manage the setup part (beginning) of the game\nconst startGame = (): Player[] => {\n\n  const numberOfPlayers: number = getNumberOfPlayer();\n\n  return createPlayer(numberOfPlayers);\n\n}\n\n//------------------------\n\n//GAME MECHANICS\n\n//------------------------\n\n\n//this function will manage the correctness of the input of the \n//number of players (a value between 1-4) and return the correct value\n//when received\nconst getNumberOfPlayer = (): number => {\n  const answer = input(`How many people are going to play? (1-4) `)\n  switch (answer) {\n    case \"1\": return 1\n    case \"2\": return 2\n    case \"3\": return 3\n    case \"4\": return 4\n    default: {\n      printInformation(\"Invalid number, please choose a number of players(1-4) \")\n      return getNumberOfPlayer();\n    }\n  }\n}\n\n//this function recursively use the indexes to generate the new array\n//of dice that the user wanted to keep\nconst whichDieToKeep = ([index1, ...indexes]: number[], dice: Die[]): Die[] => {\n  if (index1 !== undefined)\n    return [dice[index1], ...whichDieToKeep(indexes, dice)];\n\n  return [];\n}\n\n//this function asks the user one die to keep and manages the check on the input\nconst indexOfDie = (): number => {\n\n  const answer = input();\n\n  switch (answer) {\n    case '0':\n      return 0;\n    case '1':\n      return 1;\n    case '2':\n      return 2;\n    case '3':\n      return 3;\n    case '4':\n      return 4;\n    case '5':\n      return 5;\n    default: {\n      printInformation(\"Invalid number, please choose a number between 1-5 or 0 \");\n    }\n\n  }\n\n  return indexOfDie();\n\n}\n\n//this function gathers all the indexes for the dice that the user wants to keep\nconst indexOfDice = (counter: number, indexes: number[]): number[] => {\n\n  if (counter > N_DIES)\n    return [];\n\n  const index: number = indexOfDie();\n\n  if (index !== 0) {\n\n    if (indexes.some((i: number) => i === index)) {\n      printInformation(\"You can't choose the same die twice\");\n      return [...indexOfDice(counter, indexes)];\n    } else\n      return [index, ...indexOfDice(counter + 1, [index, ...indexes])];\n  }\n\n  return [];\n\n}\n\n//this function manages the functions for deciding which die to keep. \n//It also maps their indexes because the user inserts them from 1 to 5 \n//and instead they are needed from 0 to 4\nconst askDiceToKeep = (dice: Die[], player: Player): Die[] => {\n\n  printInformation(colorString(player.color, \"Choose the dice to keep writing their position (1-5) or (0) when you have finished\"));\n  const indexDiceKeep: number[] = indexOfDice(1, []);\n  const newDice: Die[] = indexDiceKeep.length === N_DIES ? dice\n    : whichDieToKeep(indexDiceKeep.map((i: number) => i - 1), dice);\n\n  return newDice;\n\n}\n\n\n//it asks the user which combination he/she wants to assign points to\nconst askCombination = (player: Player): number => {\n\n  printInformation(colorString(player.color, \"Which of the combination, you'd like to assign your dice points?\"));\n\n  const answer = input();\n\n  const combination: Score | undefined = player.score.find((s: Score) => s.name === answer);\n\n  if (combination === undefined) {\n    printInformation(\"Invalid choice, you must use the names of the combinations, displayed in the point table\");\n    return askCombination(player);\n  }\n\n  if (combination.used === true) {\n    printInformation(\"You can't assign the score to this combination because you already did in the past! Please choose another one\");\n    return askCombination(player);\n  }\n\n  return combination.position;\n\n}\n\n\n//this function will take care to convert the combination of the dice chosen in its score\nconst getScoreComputation = (combination: number): fromDiceToScore => {\n\n  switch (combination) {\n    case 0:\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n      return diceSumIfNum(combination + 1);\n    case 6:\n    case 7:\n      return numOfAKind(combination - 3);\n    case 8:\n      return fullHouse(25);\n    case 12:\n      return YAHTZEE(50);\n    case 9:\n      return isSmallStraight(30);\n    case 10:\n      return isLargeStraight(40);\n    case 11:\n      return Chance();\n\n  }\n\n  return (dice: Die[]): number => 0;\n\n}\n\n//this function manages the update of the player score\nconst newPlayerScore = (converter: fromDiceToScore, combination: number, { score, ...player }: Player, dice: Die[]): Player => {\n\n  const beforeScore: Score[] = score.slice(0, combination);\n  const afterScore: Score[] = score.slice(combination + 1, score.length);\n  const currentScore: Score = score[combination];\n\n  return {\n    score: [...beforeScore,\n    {\n      value: converter(dice),\n      used: true,\n      name: currentScore.name,\n      position: currentScore.position\n    },\n    ...afterScore],\n    ...player\n  };\n\n}\n\n//returns the total score of a player\nconst getTotalScore = (player: Player): number => player.score.reduce((sum: number, n: Score): number => sum = sum + n.value, 0)\n\n//temporary objects for determinating which player has the highest total score\ninterface PlayerAndScore {\n  player: Player,\n  total: number\n}\n\n//it sorts the player by their points gathering them first in this special temporary data structure PlayerAndScore\nconst sortPlayersByPoints = (players: Player[]): PlayerAndScore[] => players\n  .map((player: Player): PlayerAndScore =>\n  ({\n    player: player,\n    total: getTotalScore(player)\n  })\n  )\n  .sort((p1: PlayerAndScore, p2: PlayerAndScore) => p2.total - p1.total);\n\n//return a winner or more if there's a draw\nconst getWinner = (players: Player[]): Player[] => {\n\n  const sortedPlayersWPoints: PlayerAndScore[] = sortPlayersByPoints(players);\n\n  return sortedPlayersWPoints\n    .filter(({ player, total }: PlayerAndScore) => total === sortedPlayersWPoints[0].total)\n    .map(({ player, total }: PlayerAndScore): Player => player);\n}\n\n\n//this function manages the turn of a player in which he rolls dice\nconst turn = (currentPlayer: Player, numberRound: 1 | 2 | 3, dice: Die[]): Player => {\n\n  const tempDice: Die[] = [...dice, ...rollDice(N_DIES - dice.length)];\n\n  if (dice.length != 5) {\n    printInformation(`The dice have been rolled\nTheir values are: \n${prettyStringDice(tempDice)}`);\n  }\n\n  if (numberRound !== 3) {\n\n    const keptDice: Die[] = askDiceToKeep(tempDice, currentPlayer);\n\n    printInformation(`You kept the following dice: \n${prettyStringDice(keptDice)}\n`);\n\n    if (keptDice.length === N_DIES)\n      return turn(currentPlayer, 3, keptDice);\n\n    return turn(currentPlayer, numberRound + 1 as 1 | 2 | 3, keptDice);\n\n  } else {\n\n    const combination: number = askCombination(currentPlayer);\n\n    return newPlayerScore(getScoreComputation(combination), combination, currentPlayer, tempDice);\n\n  }\n\n  return { ...currentPlayer };\n\n}\n\n//computes who's the next player to play\nconst whosNext = (playerNumber: number, nPlayers: number): number => (playerNumber + 1) % nPlayers;\n\n//computes which number is the next round\nconst nextRound = (playerNumber: number, currentRound: number): number => playerNumber === 0 ? currentRound + 1 : currentRound;\n\n//this function manages all the middle part of the game in which players actually play\nconst midGame = (players: Player[], playerNumber: number, numberRound: number): Player[] => {\n\n  console.clear();\n\n  printInformation(generateBoard(players));\n\n  if (playerNumber === 0 && numberRound === 14)\n    return getWinner(players);\n\n  printInformation(midGameScreenInformation(numberRound, players[playerNumber]));\n\n  const newPlayerState: Player = turn(players[playerNumber], 1, []);\n\n  const newPlayers: Player[] = players;\n  newPlayers[playerNumber] = newPlayerState;\n\n  const next: number = whosNext(playerNumber, players.length);\n\n  return midGame(newPlayers, next, nextRound(next, numberRound));\n}\n\n//this function will manage the structure of the game itself\n//referring to any possible and needed state of the game\nconst game = (): void => {\n\n  printInformation('Welcome to Yahtzee Game!');\n\n  const players: Player[] = startGame();\n\n  //return the winner(s) or null if there's a total draw\n  const winner: Player[] = midGame(players, 0, 1);\n\n  announceWinner(winner);\n\n}\n\n\n//------------------------\n\n//USER INTERFACE & INTERACTION \n\n//------------------------\n\n//gives back the information during the beginnning of the turn\nconst midGameScreenInformation = (numberRound: number, player: Player): string => {\n\n  let result = \"Turn Number #\" + numberRound + \"\\n\";\n\n  result += colorString(player.color, \"It's your turn, color \" + getColor(player.color));\n\n  return result;\n\n}\n\n//from the string code it gives the name of the color\nconst getColor = (color: string): string => {\n  switch (color) {\n    case '\\x1b[42m':\n      return 'GREEN';\n    case '\\x1b[43m':\n      return 'YELLOW';\n    case '\\x1b[44m':\n      return 'BLUE';\n    case '\\x1b[45m':\n      return 'MAGENTA';\n  }\n\n  return '????'\n}\n\n//it announces the winner\nconst announceWinner = (players: Player[]): void => {\n\n  printInformation(\"The game is finished.\")\n\n  if (players.length === 1)\n    printInformation(`...and the winner is...\n    ... ` + colorString(players[0].color,\n      `COLOR ${getColor(players[0].color)}! Congratulations!`));\n  else\n    printInformation(`...ugh... it seems there's a draw!\nSo the winners are...\n    ... COLOR ${players.reduce((sum: string, p: Player): string => sum = sum + (sum !== '' ? \", \" : '') + colorString(p.color, getColor(p.color)), '')}! Congratulations!`);\n}\n\n//it prints on the screen\nconst printInformation = (information: string) => {\n  console.log(information);\n}\n\n//return a specified number of characters in just one string\nconst putChar = (num: number, char: string): string => {\n\n  let result: string = \"\";\n\n  for (let i = 0; i < num; i++)\n    result += char;\n\n  return result;\n}\n\n//given a string and a number, it returns that string inside the number of blank spaces specified. Considering that one is put in front of the string and the rest after\nconst fillChar = (num: number, name: string): string => {\n\n  let result: string = name;\n\n  if (name.length < num) {\n    result = \" \" + result;\n    if (name.length < num - 1)\n      result = result + putChar(num - result.length, \" \")\n  }\n\n  return result;\n}\n\n//it colors a string of the color specified\nconst colorString = (color: string, content: string): string => `${color}${content}${Reset}`;\n\n//it makes the array of dice as a good looking string\nconst prettyStringDice = (dice: Die[]): string => {\n  let diceString: string = \"\";\n\n  for (let i = 0; i < dice.length; i++) {\n    diceString += `${BgWhite} ${dice[i]} ${Reset}   `\n  }\n\n  return diceString;\n}\n\n//returns the number of points to put for the cell of the combination for the player requested\nconst getPointsPerCell = (player: Player, combination: number, N_CHAR_COL2: number): string => {\n\n  const numDisplay: string = player.score[combination].value.toString();\n\n  return !player.score[combination].used ? fillChar(N_CHAR_COL2, numDisplay) : colorString(BgWhite, fillChar(N_CHAR_COL2, numDisplay));\n\n}\n\n//it generates the cell to be placed based on which number it is now\nconst generateCell = (indexCol: number, indexRow: number, players: Player[], N_CHAR_COL1: number, N_CHAR_COL2: number): string => {\n\n  let cell = \"\";\n\n  if (indexCol < 0)\n    if (indexRow < 0)\n      cell += putChar(N_CHAR_COL1, ' ');\n    else\n      if (indexRow < players[0].score.length)\n        cell += fillChar(N_CHAR_COL1, players[0].score[indexRow].name);\n      else\n        cell += fillChar(N_CHAR_COL1, \"TOTAL SCORE\");\n  else\n    if (indexRow < 0)\n      cell += colorString(players[indexCol].color, fillChar(N_CHAR_COL2, getColor(players[indexCol].color)));\n    else\n      if (indexRow < players[0].score.length)\n        cell += getPointsPerCell(players[indexCol], indexRow, N_CHAR_COL2);\n      else\n        cell += fillChar(N_CHAR_COL2,\n          getTotalScore(players[indexCol]).toString());\n\n  return cell;\n}\n\n//it generates the row to be printed\nconst generateRow = (players: Player[], n_row: number, N_CHAR_COL1: number, N_CHAR_COL2: number): string => {\n\n  let row = \"\";\n\n  for (let j = 0; j < players.length + 1; j++) {\n\n    const indexCol = j - 1; //because the first col doesnt refer to any player\n    const indexRow = n_row - 1;\n\n    row += generateCell(indexCol, indexRow, players, N_CHAR_COL1, N_CHAR_COL2);\n\n    row += \"|\";\n\n  }\n\n  return row;\n\n}\n\n//it prints the board of the game\nconst generateBoard = (players: Player[]): string => {\n\n  const N_CHAR_COL1: number = 18; //represent the char space of the first column part\n  const N_CHAR_COL2: number = 9; //represent the char space from the second column on\n\n  const separator: string = putChar(N_CHAR_COL1 + (N_CHAR_COL2 + 1) * players.length, \"-\");\n\n  let result: string = \"\\n\";\n\n  for (let i = 0; i < players[0].score.length + 2; i++) {\n\n    if (i === 1 || i === players[0].score.length + 1)\n      result += separator + \"\\n\";\n\n    result += generateRow(players, i, N_CHAR_COL1, N_CHAR_COL2) + \"\\n\";\n\n  }\n\n  result += \"\\n\\n\";\n\n  return result;\n}\n\n\n//game call\n\ngame();\n\n\n"],
  "mappings": "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",
  "names": []
}

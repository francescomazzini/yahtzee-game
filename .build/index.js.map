{
  "version": 3,
  "sources": ["../index.ts"],
  "sourcesContent": ["// this is a library we need, to read text input \"easily\"\nimport prompt from 'prompt-sync';\n\nconst input = prompt();\n\n// these are some codes to get the console to print in colors\n// see more details here:\n// https://bit.ly/3T8YcDQ\nconst Reset = \"\\x1b[0m\";\nconst BgRed = \"\\x1b[41m\";\nconst BgGreen = \"\\x1b[42m\";\nconst BgYellow = \"\\x1b[43m\";\nconst BgBlue = \"\\x1b[44m\";\nconst BgMagenta = \"\\x1b[45m\";\nconst BgCyan = \"\\x1b[46m\";\nconst BgWhite = \"\\x1b[47m\";\n\n//define the player interface\ninterface Player {\n  //color can be green, yellow, blue or magenta\n  color: string,\n  // color: string,\n  score: number[]\n}\n\nconst N_DIES: number = 5;\n\ntype Die = 1 | 2 | 3 | 4 | 5 | 6;\n\n//this function creates the number of player wanted and set up their colors and score (default value)\nconst createPlayer = (numberNewPlayer: number): Player[] => {\n\n  if (numberNewPlayer < 1)\n    return [];\n\n  return [...createPlayer(numberNewPlayer - 1), {\n    color:\n      `\\x1b[4${numberNewPlayer + 1}m`, score: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  }];\n\n}\n\n\n//this function will manage the setup part (beginning) of the game\nconst startGame = (): Player[] => {\n\n  console.log('Welcome to Yahtzee Game!');\n\n  //magari dovrei separare e emettere questo in un'altra funzione per ridurre l'uso dell'interazione\n\n  const numberOfPlayers: number = getNumberOfPlayer();\n\n  return createPlayer(numberOfPlayers);\n\n}\n\n//this function will manage the correctness of the input of the \n//number of players (a value between 1-4) and return the correct value\n//when received\nconst getNumberOfPlayer = (): number => {\n  const answer = input(`How many people are going to play? (1-4) `)\n  switch (answer) {\n    case \"1\": return 1\n    case \"2\": return 2\n    case \"3\": return 3\n    case \"4\": return 4\n    default: {\n      console.log(\"Invalid number, please choose a number of players(1-4) \")\n      return getNumberOfPlayer();\n    }\n  }\n}\n\n//this functions roll a number of dice\nconst rollDice = (numberDice: number): Die[] => {\n  if (numberDice < 1)\n    return [];\n  else\n    return [(Math.trunc(Math.random() * 6) + 1) as Die, ...rollDice(numberDice - 1)];\n}\n\n//this function recursively use the indexes to generate the new array\n//of dice that the user wanted to keep\nconst whichDieToKeep = ([index1, ...indexes]: number[], dice: Die[]): Die[] => {\n  if (index1 !== undefined)\n    return [dice[index1], ...whichDieToKeep(indexes, dice)];\n\n  return [];\n}\n\n//this function asks the user one die to keep and manages the check on the input\nconst indexOfDie = (): number => {\n\n  console.log(`Which of the dice, would you like to keep? Write the number of their position (1-5) or write 0 to stop choosing (if you don't want any, write immediately 0)`)\n\n  const answer = input();\n\n  //VALUTA IL RAGGRUPPARE QUESTI SWITCH IN UNA FUNZIONE, MAGARI HIGH ORDER FUNCTIONS???\n\n  switch (answer) {\n    case '0':\n      return 0;\n    case '1':\n      return 1;\n    case '2':\n      return 2;\n    case '3':\n      return 3;\n    case '4':\n      return 4;\n    case '5':\n      return 5;\n    default: {\n      console.log(\"Invalid number, please choose a number between 1-5 or 0 \");\n    }\n\n  }\n\n  return indexOfDie();\n\n}\n\n//this function gathers all the indexes for the dice that the user wants to keep\nconst indexOfDice = (counter: number, indexes: number[]): number[] => {\n\n  if (counter > N_DIES)\n    return [];\n\n  const index: number = indexOfDie();\n\n  if (index !== 0) {\n\n    if (indexes.some((i: number) => i === index)) {\n      console.log(\"You can't choose the same die twice\");\n      return [...indexOfDice(counter, indexes)];\n    } else\n      return [index, ...indexOfDice(counter + 1, [index, ...indexes])];\n  }\n\n  return [];\n\n}\n\n//this function manages the functions for deciding which die to keep. \n//It also maps their indexes because the user inserts them from 1 to 5 \n//and instead they are needed from 0 to 4\nconst askDiceToKeep = (dice: Die[]): Die[] => {\n\n  const indexDiceKeep: number[] = indexOfDice(1, []);\n  const newDice: Die[] = indexDiceKeep.length === N_DIES ? dice\n    : whichDieToKeep(indexDiceKeep.map((i: number) => i - 1), dice);\n\n  console.log(\"You kept the following dice: \");\n  console.log(newDice);\n\n  return newDice;\n\n}\n\n//this function takes care to transform the combination chosen as a string to a number that refers to the cell of the array of the score owned by the player\nconst transformCombination = (): number => {\n\n  console.log(`Which of the combination, you'd like to assign your dice points?`)\n\n  const answer = input();\n\n  //VALUTA IL RAGGRUPPARE QUESTI SWITCH IN UNA FUNZIONE, MAGARI HIGH ORDER FUNCTIONS???\n\n  switch (answer) {\n    case 'Ones':\n      return 0;\n    case 'Twos':\n      return 1;\n    case 'Threes':\n      return 2;\n    case 'Fours':\n      return 3;\n    case 'Fives':\n      return 4;\n    case 'Sixes':\n      return 5;\n    case 'Three of a kind':\n      return 6;\n    case 'Four of a kind':\n      return 7;\n    case 'Full House':\n      return 8;\n    case 'Small straight':\n      return 9;\n    case 'Large straight':\n      return 10;\n    case 'Chance':\n      return 11;\n    case 'YAHTZEE':\n      return 12;\n    default: {\n      console.log(\"Invalid choice, you must use the names of the combinations, displayed in the point table\");\n    }\n\n  }\n\n  return transformCombination();\n\n}\n\n//this function takes care of all of the process of asking in which combination wants now the player put its gaines points and its main task is to check that the user is not trying to put the points on a combination already filled\nconst askCombination = ({ score, ...player }: Player): number => {\n\n  const combinationChosen: number = transformCombination();\n\n  if (score[combinationChosen] !== 0) {\n    console.log(\"You can't assign the score to this combination because you already did in the past! Please choose another one\");\n    return askCombination({ score, ...player });\n  }\n\n  return combinationChosen;\n\n}\n\n//all the functions that are going to take care to evaluate the number of points will be of the following type\ntype fromDiceToScore = (arg: Die[]) => number;\n\n//this function will take care to convert the combination of the Dies chosen in its score\nconst getScoreComputation = (combination: number): fromDiceToScore => {\n\n  switch (combination) {\n    case 0:\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n      return (dice: Die[]): number => dice.filter((d: Die) => d === (combination + 1)).reduce((sum: number, d: Die) => sum + d, 0);\n    case 6:\n    case 7:\n    case 8:\n      {\n\n        const frequencyMap = (dice: Die[]): number[] => dice.map((die: Die): number => dice.reduce((sum: number, d1: Die) => sum + d1 === die ? 1 : 0, 0));\n\n        switch (combination) {\n          case 6:\n          case 7:\n            return (dice: Die[]): number => {\n              const isThereAtLeastN: boolean = frequencyMap(dice).some((n: number) => n >= (combination - 3));\n              return isThereAtLeastN ? dice.reduce((sum: number, d: Die) => sum + d, 0) : 0;\n            }\n          case 8:\n            return (dice: Die[]): number => {\n\n              ///POSSO GENERALIZZARE QUESTO FREQUENCY MAP E ISTHERE?\n\n              const isThere3: boolean = frequencyMap(dice).some((n: number) => n === 3);\n              const isThere2: boolean = frequencyMap(dice).some((n: number) => n === 2);\n\n              return isThere3 && isThere3 ? 25 : 0;\n            }\n\n        }\n      }\n\n    //QUA POSSO GENERALIZZARE SOTTO I DUE CASE E CREARE LA FUNZIONE E PER I DUE CASE DIVERSI MODIFICARE IL PEZZETTO PASSANDO LA FUNZIONE E IL PUNTEGGIO CREDO\n    case 9:\n\n      return (dice: Die[]): number => {\n        const sortedDice: Die[] = [...dice].sort((a: number, b: number) => a - b)\n\n        const isSmallStr: boolean = [...new Set(sortedDice)].reduce((isIt: boolean, d: Die, i: number, ds: Die[]): boolean => {\n          if (i < ds.length - 1 && i > 0)\n            isIt = isIt && d === (ds[i + 1] - 1);\n          else\n            isIt = isIt && (ds[0] === (ds[1] - 1) || ds[ds.length -2] === (ds[ds.length - 3] + 1) || ds[ds.length - 1] === (ds[ds.length - 2] + 1));\n          console.log(isIt)\n          return isIt && ds.length >= 4;\n        }, true)\n\n        console.log(dice);\n        console.log([...dice].sort((a: number, b: number) => a - b));\n        console.log(isSmallStr);\n\n        return isSmallStr ? 30 : 0;\n      }\n\n    case 10:\n\n      return (dice: Die[]): number => {\n        const isLargeStr = [...dice].sort((a: number, b: number) => a - b).reduce((isIt: boolean, d: Die, i: number, ds: Die[]): boolean => {\n          if (i < ds.length)\n            isIt = isIt && d === (ds[i + 1] - 1);\n          else\n            isIt = isIt && ds[ds.length-1] === (ds[ds.length - 2] + 1);\n\n          return isIt;\n        }, true)\n\n        return isLargeStr ? 40 : 0;\n      }\n\n    case 11:\n      return (dice: Die[]): number => dice.reduce((sum: number, d: Die): number => sum + d, 0);\n\n    case 12:\n      return (dice: Die[]): number => {\n        const frequencyMap: number[] = dice.map((die: Die): number => dice.reduce((sum: number, d1: Die) => sum + d1 === die ? 1 : 0, 0));\n        const isThere5: boolean = frequencyMap.some((n: number) => n === 5);\n\n        return isThere5 ? 50 : 0;\n      }\n\n  }\n\n  return (dice: Die[]): number => 0;\n\n}\n\n//this function manages the update of the player score\nconst newPlayerScore = (converter: fromDiceToScore, combination: number, { score, ...player }: Player, dice: Die[]): Player => {\n\n  const newScore = [...score];\n\n  newScore[combination] = converter(dice);\n\n  return { score: newScore, ...player };\n}\n\n//this function manages the turn of a player in which he rolls dice\nconst turn = (currentPlayer: Player, numberRound: 1 | 2 | 3, dice: Die[]): Player => {\n\n  const tempDice: Die[] = [...dice, ...rollDice(N_DIES - dice.length)];\n\n  console.log(\"The dice have been rolled\");\n  console.log(\"Their values are: \");\n  console.log(tempDice);\n\n  if (numberRound !== 3) {\n    const keptDice: Die[] = askDiceToKeep(tempDice);\n\n    if (keptDice.length === N_DIES)\n      return turn(currentPlayer, 3, keptDice);\n\n    return turn(currentPlayer, numberRound + 1 as 1 | 2 | 3, keptDice);\n\n  } else {\n\n    const combination: number = askCombination(currentPlayer);\n\n    return newPlayerScore(getScoreComputation(combination), combination, currentPlayer, tempDice);\n\n  }\n\n  return { ...currentPlayer };\n\n}\n\nconst getWinner = (players: Player[]): Player[] => {\n  // return players.map((player: Player[], i: number) => ({ player: player, num: i })).sort()//posso fare il sort sul number e poi filter dei player con il punteggio piu alto, ma devo ptims prt ciascuno calcolare il totale dei loro punti \n\n  interface playerWScore {\n    player: Player,\n    total: number\n  }\n\n  const sortedByPoints: playerWScore[] = players\n    .map((player: Player): playerWScore =>\n    ({\n      player: player,\n      total: player.score\n        .reduce((sum: number, n: number): number => sum = sum + n, 0)\n    })\n    )\n    .sort((p1: playerWScore, p2: playerWScore) => p2.total - p1.total);\n\n  return sortedByPoints\n    .filter(({ player, total }: playerWScore) => total === sortedByPoints[0].total)\n    .map(({ player, total }: playerWScore): Player => player);\n}\n\n//this function manages all the middle part of the game in which players actually play\nconst midGame = (players: Player[], playerNumber: number, numberRound: number): Player[] => {\n\n  if (playerNumber === 0 && numberRound === 14)\n    return getWinner(players);\n\n  if (playerNumber === 0)\n    console.log(\"Turn Number #\" + numberRound);\n\n  console.log(players);\n  console.log(\"It's your turn, color \" + getColor(players[playerNumber].color));\n\n  const newPlayerState: Player = turn(players[playerNumber], 1, []);\n\n  const newPlayers: Player[] = players;\n  newPlayers[playerNumber] = newPlayerState;\n\n  const next: number = (playerNumber + 1) % players.length;\n\n  return midGame(newPlayers, next, next === 0 ? numberRound + 1 : numberRound);\n}\n\nconst getColor = (color: string): string => {\n  switch (color) {\n    case '\\x1b[42m':\n      return 'GREEN';\n    case '\\x1b[43m':\n      return 'YELLOW';\n    case '\\x1b[44m':\n      return 'BLUE';\n    case '\\x1b[45m':\n      return 'MAGENTA';\n  }\n\n  return '????'\n}\n\nconst announceWinner = (players: Player[]): void => {\n\n  console.log(\"The game is finished.\")\n\n  if (players.length === 1)\n    console.log(`...and the winner is...\n    ...COLOR ${getColor(players[0].color)}. Congratulations!`);\n  else\n    console.log(`...ugh... it seems there's a draw!\n    So the winners are...\n    ... COLOR ${players.reduce((sum: string, p: Player): string => sum = sum + \", \" + getColor(p.color), '')}. Congratulations!`);\n}\n\n//this function will manage the structure of the game itself\n//referring to any possible and needed state of the game\nconst game = (): void => {\n  const players: Player[] = startGame();\n\n  //return the winner(s) or null if there's a total draw\n  const winner: Player[] = midGame(players, 0, 1);\n\n  announceWinner(winner);\n\n  //fai funzione announcewinner che controlla se ne e' piu' di uno con lo stesso score o solo uno e in caso scrive la cosa adatt\n}\n\ngame();\n\n\n\n\n\n\n// const throwDie = (): number => Math.trunc(Math.random() * 6) + 1;\n\n\n// this is a small example to show how the pieces fit together\n// const example = (): void => {\n//   console.log(`type anything to throw a die, or ${BgRed}'exit'${Reset} to quit`);\n//   const command: string = input();\n//   if (command == 'exit') {\n//     console.log(`${BgGreen}See you next time!${Reset}`);\n//   } else {\n//     const die = throwDie();\n//     console.log(`you threw: ${BgBlue} ${die} ${Reset}`);\n//     example();\n//   }\n// }\n\n// example();\n"],
  "mappings": "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",
  "names": []
}
